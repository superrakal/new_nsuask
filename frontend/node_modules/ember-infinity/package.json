{
  "name": "ember-infinity",
  "version": "0.2.1",
  "description": "Simple, flexible infinite scroll for Ember CLI Apps.",
  "directories": {
    "doc": "doc",
    "test": "tests"
  },
  "scripts": {
    "start": "ember server",
    "build": "ember build",
    "test": "ember try:testall"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/hhff/ember-infinity"
  },
  "engines": {
    "node": ">= 0.10.0"
  },
  "author": {
    "name": "Hugh Francis"
  },
  "license": "MIT",
  "devDependencies": {
    "ember-data": "1.13.11",
    "broccoli-asset-rev": "^2.1.2",
    "ember-cli": "1.13.8",
    "ember-cli-app-version": "0.5.0",
    "ember-cli-content-security-policy": "0.4.0",
    "ember-cli-dependency-checker": "^1.0.1",
    "ember-cli-github-pages": "0.0.6",
    "ember-cli-htmlbars-inline-precompile": "0.2.0",
    "ember-cli-ic-ajax": "0.2.1",
    "ember-cli-inject-live-reload": "^1.3.1",
    "ember-cli-pretender": "0.3.2",
    "ember-cli-qunit": "^1.0.0",
    "ember-cli-uglify": "^1.2.0",
    "ember-disable-prototype-extensions": "^1.0.0",
    "ember-disable-proxy-controllers": "^1.0.0",
    "ember-export-application-global": "^1.0.2",
    "ember-faker": "1.1.0",
    "ember-try": "0.0.6"
  },
  "keywords": [
    "ember-addon"
  ],
  "dependencies": {
    "ember-cli-babel": "^5.1.3",
    "ember-cli-htmlbars": "^1.0.1",
    "ember-cli-version-checker": "^1.0.2",
    "ember-version-is": "0.0.3"
  },
  "ember-addon": {
    "configPath": "tests/dummy/config",
    "demoURL": "http://hhff.github.io/ember-infinity/"
  },
  "readme": "# Ember Infinity\n[![Build Status](https://travis-ci.org/hhff/ember-infinity.svg)](https://travis-ci.org/hhff/ember-infinity)\n[![npm version](https://badge.fury.io/js/ember-infinity.svg)](http://badge.fury.io/js/ember-infinity)\n[![Ember Observer Score](http://emberobserver.com/badges/ember-infinity.svg)](http://emberobserver.com/addons/ember-infinity)\n\n[![Code Climate](https://codeclimate.com/github/hhff/ember-infinity/badges/gpa.svg)](https://codeclimate.com/github/hhff/ember-infinity)\n[![Dependency Status](https://david-dm.org/hhff/ember-infinity.svg)](https://david-dm.org/hhff/ember-infinity)\n[![devDependency Status](https://david-dm.org/hhff/ember-infinity/dev-status.svg)](https://david-dm.org/hhff/ember-infinity#info=devDependencies)\n\n***As of v0.1.0, this library officially supports Ember 1.10 through to 2.0+ (Canary), and (aside from a few buggy versions), Ember Data pre-1.0 through to 2.0+ (Canary).  We plan to support 1.10 for the foreseeable future.***\n\nDemo: [hhff.github.io/ember-infinity/](http://hhff.github.io/ember-infinity/)\n\nSimple, flexible infinite scrolling for Ember CLI Apps.  Works out of the box\nwith the [Kaminari Gem](https://github.com/amatsuda/kaminari.git).\n\nInspired by @bantic's [Ember Infinite Scroll](https://github.com/bantic/ember-infinite-scroll)\nrepo, but without using controllers, in preparation for Ember 2.0.\n\n## Installation\n\n`ember install ember-infinity`\n\n**Note:** If you're getting an error like `semver is not defined`, you probably did `npm install` instead of `ember install`.  We use [ember-version-is](https://github.com/hhff/ember-version-is) to manage the code for different versions of Ember & Ember Data, which relies on semver.  `npm install` won't run the nested generator that adds semver to your app.\n\n## Basic Usage\n\n```js\nimport Ember from 'ember';\nimport InfinityRoute from \"ember-infinity/mixins/route\";\n\nexport default Ember.Route.extend(InfinityRoute, {\n  model() {\n    /* Load pages of the Product Model, starting from page 1, in groups of 12. */\n    return this.infinityModel(\"product\", { perPage: 12, startingPage: 1 });\n  }\n});\n```\n\nThen, you'll need to add the Infinity Loader component to your template, like so:\n\n```hbs\n{{#each model as |product|}}\n  <h1>{{product.name}}</h1>\n  <h2>{{product.description}}</h2>\n{{/each}}\n\n{{infinity-loader infinityModel=model}}\n```\n\nNow, whenever the `infinity-loader` is in view, it will send an action to the route\n(the one where you initialized the infinityModel) to start loading the next page.\n\nWhen the new records are loaded, they will automatically be pushed into the Model array.\n\n## Advanced Usage\n\n### JSON Request/Response Customization\n\nBy default, ember-infinity will send pagination parameters as part of a GET request as follows\n\n```\n/items?per_page=5&page=1\n```\n\nand will expect to recieve metadata in the response payload via a `total_pages` param in a `meta` object\n\n```js\n{\n  items: [\n    {id: 1, name: 'Test'},\n    {id: 2, name: 'Test 2'}\n  ],\n  meta: {\n    total_pages: 3\n  }\n}\n```\n\nIf you wish to customize some aspects of the JSON contract for pagination, you may do so via your routes. For example: \n\n```js\nimport Ember from 'ember';\nimport InfinityRoute from \"ember-infinity/mixins/route\";\n\nexport default Ember.Route.extend(InfinityRoute, {\n  \n  perPageParam: \"per\",              // instead of \"per_page\"\n  pageParam: \"pg\",                  // instead of \"page\"\n  totalPagesParam: \"meta.total\",    // instead of \"meta.total_pages\"\n\n  model() {\n    /* Load pages of the Product Model, starting from page 1, in groups of 12. */\n    return this.infinityModel(\"product\", { perPage: 12, startingPage: 1 });\n  }\n});\n```\n\nThis will result in request query params being sent out as follows\n\n```\n/items?per=5&pg=1\n``` \n\nand ember-infinity will be set up to parse the total number of pages from a JSON response like this:\n\n```js\n{\n  items: [\n    ...\n  ],\n  meta: {\n    total: 3\n  }\n}\n```\n\n### Cursor-based pagination\n\nIf you are serving a continuously updating stream, it's helpful to keep track\nof your place in the list while paginating, to avoid duplicates. This is known\nas **cursor-based pagination** and is common in popular APIs like Twitter,\nFacebook, and Instagram. Instead of relying on `page_number` to paginate,\nyou'll want to extract the `min_id` or `min_updated_at` from each page of\nresults, so that you can fetch the next page without risking duplicates if new\nitems are added to the top of the list by other users in between requests.\n\nTo do this, implement the `afterInfinityModel` hook as follows:\n\n```js\nexport default Ember.Route.extend(InfinityRoute, {\n  _minId: undefined,\n  _minUpdatedAt: undefined,\n  _canLoadMore: true,\n\n  model() {\n    return this.infinityModel(\"post\", {}, {\n      min_id: '_minId',\n      min_updated_at: '_minUpdatedAt'\n    });\n  },\n\n  afterInfinityModel(posts) {\n    loadedAny = posts.get('length') > 0;\n    this.set('_canLoadMore', loadedAny);\n\n    this.set('_minId', posts.get('lastObject.id'));\n    this.set('_minUpdatedAt', posts.get('lastObject.updated_at').toISOString());\n  }\n});\n```\n\n### infinityModel\n\nYou can also provide additional static parameters to `infinityModel` that\nwill be passed to your backend server in addition to the\npagination params. For instance, in the following example a `category`\nparameter is added:\n\n```js\nreturn this.infinityModel(\"product\", { perPage: 12, startingPage: 1,\n                                       category: \"furniture\" });\n```\n\nMoreover, you can optionally pass in an object of bound parameters as a third option to `infinityModel` to further \ncustomize the request to the backend. The values of the contained parameters will be looked up against the route \nproperties and the respective values will be included in the request:\n\n```js\nimport Ember from 'ember';\nimport InfinityRoute from 'ember-infinity/mixins/route';\n\nexport default Ember.Route.extend(InfinityRoute, {\n  ...\n\n  prod: Ember.computed('cat', function () { return this.get('cat'); }),\n  country: '',\n  cat: 'shipped',\n\n  model() {\n    return this.infinityModel(\"product\", { perPage: 12, startingPage: 1, make: \"original\" }, { country: \"country\", category: \"prod\" });\n  }\n});\n```\n\nIn the example above, the query url should look like this:\n\n```\n  product?make=original&country=&category=shipped&per_page=12&page=1\n```\n\nIf the value of the bound parameter cannot be found, the parameter is not included in the request. Note that you cannot have\na static and bound parameter of the same name, the latter will take precedence.\n\nWhen you need to pass in bound parameters but no static parameters or custom pagination, call `infinityModel` with an empty object for it's second param:\n\n```js\n  return this.infinityModel(\"product\", {}, { country: \"country\", category: \"prod\" });\n```\n\n* **modelPath**\n\n`modelPath` is optional parameter for situations when you are overriding `setupController`\nor when your model is on different location than `controller.model`.\n\n```js\nmodel() {\n  return this.infinityModel(\"product\", {\n    perPage: 12,\n    startingPage: 1,\n    modelPath: 'controller.products'\n  });\n},\nsetupController(controller, model) {\n  controller.set('products', model);\n}\n```\n\n### afterInfinityModel\n\nIn some cases, a single call to your data store isn't enough. The afterInfinityModel\nmethod is available for those cases when you need to chain together functions or\npromises after fetching a model.\n\nAs a simple example, let's say you had a blog and just needed to set a property\non each Post model after fetching all of them:\n\n```js\nmodel() {\n  return this.infinityModel(\"post\");\n},\n\nafterInfinityModel(posts) {\n  posts.setEach('author', 'Jane Smith');\n}\n```\n\nAs a more complex example, let's say you had a blog with Posts and Authors as separate\nrelated models and you needed to extract an association from Posts. In that case,\nreturn the collection you want from afterInfinityModel:\n\n```js\nmodel() {\n  return this.infinityModel(\"post\");\n},\n\nafterInfinityModel(posts) {\n  return posts.mapBy('author').uniq();\n}\n```\n\n### Event Hooks\n\nThe route mixin also provides following event hooks:\n\n**infinityModelUpdated**\n\nTriggered on the route whenever new objects are pushed into the infinityModel.\n\n**Args:**\n\n* totalPages\n\n**infinityModelLoaded**\n\nTriggered on the route when the infinityModel is fully loaded.\n\n**Args:**\n\n* lastPageLoaded\n\n* totalPages\n\n* infinityModel\n\n\n```js\nimport Ember from 'ember';\nimport InfinityRoute from 'ember-infinity/mixins/route';\n\nexport default Ember.Route.extend(InfinityRoute, {\n  ...\n\n  model() {\n    /* Load pages of the Product Model, starting from page 1, in groups of 12. */\n    return this.infinityModel(\"product\", { perPage: 12, startingPage: 1 });\n  },\n\n  infinityModelUpdated(totalPages) {\n    Ember.Logger.debug('updated with more items');\n  },\n  infinityModelLoaded(lastPageLoaded, totalPages, infinityModel) {\n    Ember.Logger.info('no more items to load');\n  }\n}\n```\n\n### infinity-loader\n\nThe `infinity-loader` component as some extra options to make working with it easy!\n\n* **destroyOnInfinity**\n\n```hbs\n{{infinity-loader infinityModel=model destroyOnInfinity=true}}\n```\n\nNow, when the Infinity Model is fully loaded, the `infinity-loader` will remove itself\nfrom the page.\n\n* **developmentMode**\n\n```hbs\n{{infinity-loader infinityModel=model developmentMode=true}}\n```\n\nThis simply stops the `infinity-loader` from fetching triggering loads, so that\nyou can work on its appearance.\n\n* **loadingText & loadedText**\n\n```hbs\n{{infinity-loader infinityModel=model loadingText=\"Loading...\" loadedText=\"Loaded!\"}}\n```\n\nBy default, the `infinity-loader` will just output a `span` showing its status.\n\n* **Providing a block**\n\n```hbs\n{{#infinity-loader infinityModel=model}}\n  <img src=\"loading-spinner.gif\" />\n{{/infinity-loader}}\n```\n\nIf you provide a block to the component, it will render the block instead of\nrendering `loadingText` or `loadedText`. This will allow you to provide your\nown custom markup or styling for the loading state.\n\n* **reached-infinity Class Name**\n\n```scss\n.infinity-loader {\n  background-color: wheat;\n  &.reached-infinity {\n    background-color: lavender;\n  }\n}\n\n```\n\nWhen the Infinity Model loads entirely, the `reached-infinity` class is added to the\ncomponent.\n\n* **infinity-template Generator**\n\n`ember generate infinity-template`\n\nWill install the default `infinity-loader` template into your host app, at\n`app/templates/components/infinity-loader`.\n\n* **scrollable**\n\n```hbs\n{{infinity-loader scrollable=\"#content\"}}\n```\n\nYou can optionally pass in a jQuery style selector string.  If it's not a string,\nscrollable will default to using the window for the scroll binding.\n\n### Use ember-infinity with button\n\nYou can use the route loading magic of Ember Infinity without using the InfinityLoader component.\n\nload-more-button.js:\n\n```js\nexport default Ember.Component.extend({\n  loadText: 'Load more',\n  loadedText: 'Loaded',\n  click: function(){    \n    this.sendAction();  \n  }\n});\n```\n\nload-more-button.hbs:\n\n```hbs\n{{#if infinityModel.reachedInfinity}}\n  <button>{{loadedText}}</button>\n{{else}}\n  <button>{{loadText}}</button>\n{{/if}}  \n```\ntemplate.hbs:\n\n```hbs\n<ul class=\"test-list\">\n{{#each model as |item|}}\n  <li>{{item.name}}</li>\n{{/each}}\n</ul>\n\n{{load-more-button action='infinityLoad' infinityModel=model}}\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/hhff/ember-infinity/issues"
  },
  "_id": "ember-infinity@0.2.1",
  "_from": "ember-infinity@0.2.1"
}
